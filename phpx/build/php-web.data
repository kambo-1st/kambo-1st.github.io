<?php

/**
 * This file is used to bootstrap the application.
 * Its running fully with with a help of webassembly.
 */

 // The usage of the autoloader is supported and encouraged.
require __DIR__.'/vendor/autoload.php';

// You can freely access files on the filesystem.
require_once __DIR__.'/src/App.php';
<?php
namespace Syntaxx\PHPX\Demo;

use Syntaxx\PHPX\Framework\Component;
use Syntaxx\PHPX\Framework\Runtime;
use Syntaxx\PHPX\Framework\Document;
function MyApp()
{
    return Component::create("div", [], [Component::create("h1", [], ["Click to increment value"]), Component::create("MyButton", [], [])]);
}
function MyButton()
{
    [$count, $setCount] = useState(0);
    $handleClick = function () use ($count, $setCount) {
        $setCount($count + 1);
    };
    return Component::create("button", ["onClick" => $handleClick], [" Count: ", $count]);
}
$root = Runtime::createRoot(Document::document()->getElementById('root'));
$root->render(Component::create("StrictMode", [], [Component::create("MyApp", [], [])]));<?php

namespace Syntaxx\PHPX\Demo;

use Syntaxx\PHPX\Framework\Component;
use Syntaxx\PHPX\Framework\Runtime;
use Syntaxx\PHPX\Framework\Document;

function MyApp() {
    return (
        <div>
            <h1>Click to increment value</h1>
            <MyButton />
        </div>
    );
}

function MyButton() {
    [$count, $setCount] = useState(0);

    $handleClick = function() use ($count, $setCount) {
        $setCount($count + 1);
    };

    return (
        <button onClick={$handleClick}>
            Count: {$count}
        </button>
    );
}

$root = Runtime::createRoot(Document::document()->getElementById('root'));
$root->render(
    Component::create("StrictMode", [], [
        Component::create("MyApp", [], [])
    ])
);
<?php

$window = new Vrzno;
$document = $window->document;

// Copy the code for display
$document->getElementById('todo-source')->textContent = file_get_contents(__FILE__);

// Highlight the code
$window->hljs->highlightElement($document->getElementById('todo-source'));

$input = $document->querySelector('#todo-input');
$addButton = $document->querySelector('#add-todo');
$todoList = $document->querySelector('#todo-list');

$todoItems = [];

$addTodo = function() use(&$todoItems, $document, $input, $todoList) {
  $text = $input->value;
  
  if(trim($text) === '') {
    return;
  }
  
  $todoItems[] = $text;
  $input->value = '';
  
  // Clear the list
  $todoList->innerHTML = '';
  
  // Rebuild the list
  foreach($todoItems as $index => $item) {
    $li = $document->createElement('li');
    $li->className = 'todo-item';
    
    $span = $document->createElement('span');
    $span->textContent = $item;
    
    $deleteBtn = $document->createElement('button');
    $deleteBtn->textContent = 'Delete';
    
    // Add delete handler
    $deleteBtn->addEventListener('click', function() use($index, &$todoItems, $todoList, $document) {
      array_splice($todoItems, $index, 1);
      
      // Redraw the list
      $todoList->innerHTML = '';
      foreach($todoItems as $i => $todo) {
        $li = $document->createElement('li');
        $li->className = 'todo-item';
        
        $span = $document->createElement('span');
        $span->textContent = $todo;
        
        $deleteBtn = $document->createElement('button');
        $deleteBtn->textContent = 'Delete';
        
        $li->appendChild($span);
        $li->appendChild($deleteBtn);
        $todoList->appendChild($li);
      }
    });
    
    $li->appendChild($span);
    $li->appendChild($deleteBtn);
    $todoList->appendChild($li);
  }
};

$addButton->addEventListener('click', $addTodo);

// Handle Enter key
$input->addEventListener('keypress', function($event) use($addTodo) {
  if($event->keyCode === 13) {
    $addTodo();
  }
});
<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 50600) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.'.PHP_EOL;
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, $err);
        } elseif (!headers_sent()) {
            echo $err;
        }
    }
    trigger_error(
        $err,
        E_USER_ERROR
    );
}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInitcb2241b95e5816c1a351e6420610f531::getLoader();
#!/usr/bin/env php
<?php

/**
 * Proxy PHP file generated by Composer
 *
 * This file includes the referenced bin path (../syntaxx/phpx-compiler/bin/compile)
 * using a stream wrapper to prevent the shebang from being output on PHP<8
 *
 * @generated
 */

namespace Composer;

$GLOBALS['_composer_bin_dir'] = __DIR__;
$GLOBALS['_composer_autoload_path'] = __DIR__ . '/..'.'/autoload.php';

if (PHP_VERSION_ID < 80000) {
    if (!class_exists('Composer\BinProxyWrapper')) {
        /**
         * @internal
         */
        final class BinProxyWrapper
        {
            private $handle;
            private $position;
            private $realpath;

            public function stream_open($path, $mode, $options, &$opened_path)
            {
                // get rid of phpvfscomposer:// prefix for __FILE__ & __DIR__ resolution
                $opened_path = substr($path, 17);
                $this->realpath = realpath($opened_path) ?: $opened_path;
                $opened_path = $this->realpath;
                $this->handle = fopen($this->realpath, $mode);
                $this->position = 0;

                return (bool) $this->handle;
            }

            public function stream_read($count)
            {
                $data = fread($this->handle, $count);

                if ($this->position === 0) {
                    $data = preg_replace('{^#!.*\r?\n}', '', $data);
                }

                $this->position += strlen($data);

                return $data;
            }

            public function stream_cast($castAs)
            {
                return $this->handle;
            }

            public function stream_close()
            {
                fclose($this->handle);
            }

            public function stream_lock($operation)
            {
                return $operation ? flock($this->handle, $operation) : true;
            }

            public function stream_seek($offset, $whence)
            {
                if (0 === fseek($this->handle, $offset, $whence)) {
                    $this->position = ftell($this->handle);
                    return true;
                }

                return false;
            }

            public function stream_tell()
            {
                return $this->position;
            }

            public function stream_eof()
            {
                return feof($this->handle);
            }

            public function stream_stat()
            {
                return array();
            }

            public function stream_set_option($option, $arg1, $arg2)
            {
                return true;
            }

            public function url_stat($path, $flags)
            {
                $path = substr($path, 17);
                if (file_exists($path)) {
                    return stat($path);
                }

                return false;
            }
        }
    }

    if (
        (function_exists('stream_get_wrappers') && in_array('phpvfscomposer', stream_get_wrappers(), true))
        || (function_exists('stream_wrapper_register') && stream_wrapper_register('phpvfscomposer', 'Composer\BinProxyWrapper'))
    ) {
        return include("phpvfscomposer://" . __DIR__ . '/..'.'/syntaxx/phpx-compiler/bin/compile');
    }
}

return include __DIR__ . '/..'.'/syntaxx/phpx-compiler/bin/compile';
#!/usr/bin/env php
<?php

/**
 * Proxy PHP file generated by Composer
 *
 * This file includes the referenced bin path (../syntaxx/webassembly-packer/bin/file-packager)
 * using a stream wrapper to prevent the shebang from being output on PHP<8
 *
 * @generated
 */

namespace Composer;

$GLOBALS['_composer_bin_dir'] = __DIR__;
$GLOBALS['_composer_autoload_path'] = __DIR__ . '/..'.'/autoload.php';

if (PHP_VERSION_ID < 80000) {
    if (!class_exists('Composer\BinProxyWrapper')) {
        /**
         * @internal
         */
        final class BinProxyWrapper
        {
            private $handle;
            private $position;
            private $realpath;

            public function stream_open($path, $mode, $options, &$opened_path)
            {
                // get rid of phpvfscomposer:// prefix for __FILE__ & __DIR__ resolution
                $opened_path = substr($path, 17);
                $this->realpath = realpath($opened_path) ?: $opened_path;
                $opened_path = $this->realpath;
                $this->handle = fopen($this->realpath, $mode);
                $this->position = 0;

                return (bool) $this->handle;
            }

            public function stream_read($count)
            {
                $data = fread($this->handle, $count);

                if ($this->position === 0) {
                    $data = preg_replace('{^#!.*\r?\n}', '', $data);
                }

                $this->position += strlen($data);

                return $data;
            }

            public function stream_cast($castAs)
            {
                return $this->handle;
            }

            public function stream_close()
            {
                fclose($this->handle);
            }

            public function stream_lock($operation)
            {
                return $operation ? flock($this->handle, $operation) : true;
            }

            public function stream_seek($offset, $whence)
            {
                if (0 === fseek($this->handle, $offset, $whence)) {
                    $this->position = ftell($this->handle);
                    return true;
                }

                return false;
            }

            public function stream_tell()
            {
                return $this->position;
            }

            public function stream_eof()
            {
                return feof($this->handle);
            }

            public function stream_stat()
            {
                return array();
            }

            public function stream_set_option($option, $arg1, $arg2)
            {
                return true;
            }

            public function url_stat($path, $flags)
            {
                $path = substr($path, 17);
                if (file_exists($path)) {
                    return stat($path);
                }

                return false;
            }
        }
    }

    if (
        (function_exists('stream_get_wrappers') && in_array('phpvfscomposer', stream_get_wrappers(), true))
        || (function_exists('stream_wrapper_register') && stream_wrapper_register('phpvfscomposer', 'Composer\BinProxyWrapper'))
    ) {
        return include("phpvfscomposer://" . __DIR__ . '/..'.'/syntaxx/webassembly-packer/bin/file-packager');
    }
}

return include __DIR__ . '/..'.'/syntaxx/webassembly-packer/bin/file-packager';
#!/usr/bin/env php
<?php

/**
 * Proxy PHP file generated by Composer
 *
 * This file includes the referenced bin path (../syntaxx/phpx-parser/bin/php-parse)
 * using a stream wrapper to prevent the shebang from being output on PHP<8
 *
 * @generated
 */

namespace Composer;

$GLOBALS['_composer_bin_dir'] = __DIR__;
$GLOBALS['_composer_autoload_path'] = __DIR__ . '/..'.'/autoload.php';

if (PHP_VERSION_ID < 80000) {
    if (!class_exists('Composer\BinProxyWrapper')) {
        /**
         * @internal
         */
        final class BinProxyWrapper
        {
            private $handle;
            private $position;
            private $realpath;

            public function stream_open($path, $mode, $options, &$opened_path)
            {
                // get rid of phpvfscomposer:// prefix for __FILE__ & __DIR__ resolution
                $opened_path = substr($path, 17);
                $this->realpath = realpath($opened_path) ?: $opened_path;
                $opened_path = $this->realpath;
                $this->handle = fopen($this->realpath, $mode);
                $this->position = 0;

                return (bool) $this->handle;
            }

            public function stream_read($count)
            {
                $data = fread($this->handle, $count);

                if ($this->position === 0) {
                    $data = preg_replace('{^#!.*\r?\n}', '', $data);
                }

                $this->position += strlen($data);

                return $data;
            }

            public function stream_cast($castAs)
            {
                return $this->handle;
            }

            public function stream_close()
            {
                fclose($this->handle);
            }

            public function stream_lock($operation)
            {
                return $operation ? flock($this->handle, $operation) : true;
            }

            public function stream_seek($offset, $whence)
            {
                if (0 === fseek($this->handle, $offset, $whence)) {
                    $this->position = ftell($this->handle);
                    return true;
                }

                return false;
            }

            public function stream_tell()
            {
                return $this->position;
            }

            public function stream_eof()
            {
                return feof($this->handle);
            }

            public function stream_stat()
            {
                return array();
            }

            public function stream_set_option($option, $arg1, $arg2)
            {
                return true;
            }

            public function url_stat($path, $flags)
            {
                $path = substr($path, 17);
                if (file_exists($path)) {
                    return stat($path);
                }

                return false;
            }
        }
    }

    if (
        (function_exists('stream_get_wrappers') && in_array('phpvfscomposer', stream_get_wrappers(), true))
        || (function_exists('stream_wrapper_register') && stream_wrapper_register('phpvfscomposer', 'Composer\BinProxyWrapper'))
    ) {
        return include("phpvfscomposer://" . __DIR__ . '/..'.'/syntaxx/phpx-parser/bin/php-parse');
    }
}

return include __DIR__ . '/..'.'/syntaxx/phpx-parser/bin/php-parse';
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var \Closure(string):void */
    private static $includeFile;

    /** @var string|null */
    private $vendorDir;

    // PSR-4
    /**
     * @var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array<string, list<string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * List of PSR-0 prefixes
     *
     * Structured as array('F (first letter)' => array('Foo\Bar (full prefix)' => array('path', 'path2')))
     *
     * @var array<string, array<string, list<string>>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var array<string, bool>
     */
    private $missingClasses = array();

    /** @var string|null */
    private $apcuPrefix;

    /**
     * @var array<string, self>
     */
    private static $registeredLoaders = array();

    /**
     * @param string|null $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
        self::initializeIncludeClosure();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return array<string, string> Array of classname => path
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array<string, string> $classMap Class to filename map
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string              $prefix  The prefix
     * @param list<string>|string $paths   The PSR-0 root directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string              $prefix  The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths   The PSR-4 base directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string              $prefix The prefix
     * @param list<string>|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string              $prefix The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders keyed by their corresponding vendor directories.
     *
     * @return array<string, self>
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    /**
     * @return void
     */
    private static function initializeIncludeClosure()
    {
        if (self::$includeFile !== null) {
            return;
        }

        /**
         * Scope isolated include.
         *
         * Prevents access to $this/self from included files.
         *
         * @param  string $file
         * @return void
         */
        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }
}
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 *
 * @final
 */
class InstalledVersions
{
    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || !isset($installed['versions'][$packageName]['dev_requirement']) || $installed['versions'][$packageName]['dev_requirement'] === false;
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints((string) $constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();

        if (self::$canGetVendors) {
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                    $required = require $vendorDir.'/composer/installed.php';
                    $installed[] = self::$installedByVendor[$vendorDir] = $required;
                    if (null === self::$installed && strtr($vendorDir.'/composer', '\\', '/') === strtr(__DIR__, '\\', '/')) {
                        self::$installed = $installed[count($installed) - 1];
                    }
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                $required = require __DIR__ . '/installed.php';
                self::$installed = $required;
            } else {
                self::$installed = array();
            }
        }

        if (self::$installed !== array()) {
            $installed[] = self::$installed;
        }

        return $installed;
    }
}
<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
);
<?php

// autoload_files.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    '9e848da9eee4d08459e0600785f1f49b' => $vendorDir . '/syntaxx/phpx-framework/src/useState.php',
);
<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
);
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Tests\\' => array($vendorDir . '/syntaxx/webassembly-packer/tests'),
    'Syntaxx\\WebAssemblyPacker\\' => array($vendorDir . '/syntaxx/webassembly-packer/src'),
    'Syntaxx\\PhpWasm\\' => array($vendorDir . '/syntaxx/wasm-php-runtime-vrzno/src'),
    'Syntaxx\\PHPX\\Framework\\' => array($vendorDir . '/syntaxx/phpx-framework/src'),
    'Syntaxx\\PHPX\\' => array($vendorDir . '/syntaxx/phpx-compiler/src'),
    'Syntaxx\\LZ4\\' => array($vendorDir . '/syntaxx/lz4/src'),
    'PhpParser\\' => array($vendorDir . '/syntaxx/phpx-parser/lib/PhpParser'),
    'App\\' => array($baseDir . '/src'),
);
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInitcb2241b95e5816c1a351e6420610f531
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInitcb2241b95e5816c1a351e6420610f531', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInitcb2241b95e5816c1a351e6420610f531', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInitcb2241b95e5816c1a351e6420610f531::getInitializer($loader));

        $loader->register(true);

        $filesToLoad = \Composer\Autoload\ComposerStaticInitcb2241b95e5816c1a351e6420610f531::$files;
        $requireFile = \Closure::bind(static function ($fileIdentifier, $file) {
            if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
                $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;

                require $file;
            }
        }, null, null);
        foreach ($filesToLoad as $fileIdentifier => $file) {
            $requireFile($fileIdentifier, $file);
        }

        return $loader;
    }
}
<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInitcb2241b95e5816c1a351e6420610f531
{
    public static $files = array (
        '9e848da9eee4d08459e0600785f1f49b' => __DIR__ . '/..' . '/syntaxx/phpx-framework/src/useState.php',
    );

    public static $prefixLengthsPsr4 = array (
        'T' => 
        array (
            'Tests\\' => 6,
        ),
        'S' => 
        array (
            'Syntaxx\\WebAssemblyPacker\\' => 26,
            'Syntaxx\\PhpWasm\\' => 16,
            'Syntaxx\\PHPX\\Framework\\' => 23,
            'Syntaxx\\PHPX\\' => 13,
            'Syntaxx\\LZ4\\' => 12,
        ),
        'P' => 
        array (
            'PhpParser\\' => 10,
        ),
        'A' => 
        array (
            'App\\' => 4,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'Tests\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/webassembly-packer/tests',
        ),
        'Syntaxx\\WebAssemblyPacker\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/webassembly-packer/src',
        ),
        'Syntaxx\\PhpWasm\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/wasm-php-runtime-vrzno/src',
        ),
        'Syntaxx\\PHPX\\Framework\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/phpx-framework/src',
        ),
        'Syntaxx\\PHPX\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/phpx-compiler/src',
        ),
        'Syntaxx\\LZ4\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/lz4/src',
        ),
        'PhpParser\\' => 
        array (
            0 => __DIR__ . '/..' . '/syntaxx/phpx-parser/lib/PhpParser',
        ),
        'App\\' => 
        array (
            0 => __DIR__ . '/../..' . '/src',
        ),
    );

    public static $classMap = array (
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInitcb2241b95e5816c1a351e6420610f531::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInitcb2241b95e5816c1a351e6420610f531::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInitcb2241b95e5816c1a351e6420610f531::$classMap;

        }, null, ClassLoader::class);
    }
}
{
    "packages": [
        {
            "name": "syntaxx/lz4",
            "version": "v0.1.0",
            "version_normalized": "0.1.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/Syntaxx-HQ/PHPX-Lz4.git",
                "reference": "f8e11ff917bfd4a0e5842d355020a562b395ce4a"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/Syntaxx-HQ/PHPX-Lz4/zipball/f8e11ff917bfd4a0e5842d355020a562b395ce4a",
                "reference": "f8e11ff917bfd4a0e5842d355020a562b395ce4a",
                "shasum": ""
            },
            "require": {
                "php": ">=8.1"
            },
            "require-dev": {
                "phpunit/phpunit": "^10.0",
                "slevomat/coding-standard": "^8.0",
                "squizlabs/php_codesniffer": "^3.7"
            },
            "time": "2025-05-17T14:28:06+00:00",
            "type": "library",
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Syntaxx\\LZ4\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "license": [
                "MIT"
            ],
            "description": "A pure PHP implementation of LZ4 compression and decompression",
            "keywords": [
                "compression",
                "decompression",
                "lz4"
            ],
            "support": {
                "issues": "https://github.com/Syntaxx-HQ/PHPX-Lz4/issues",
                "source": "https://github.com/Syntaxx-HQ/PHPX-Lz4/tree/v0.1.0"
            },
            "install-path": "../syntaxx/lz4"
        },
        {
            "name": "syntaxx/phpx-compiler",
            "version": "dev-main",
            "version_normalized": "dev-main",
            "dist": {
                "type": "path",
                "url": "../PHPX-Compiler",
                "reference": "b413b2de4d4f4f40224ddf4aa78f0795230577b9"
            },
            "require": {
                "syntaxx/phpx-parser": "4.19.4"
            },
            "require-dev": {
                "phpunit/phpunit": "^10.0"
            },
            "bin": [
                "bin/compile"
            ],
            "type": "project",
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Syntaxx\\PHPX\\": "src/"
                }
            },
            "autoload-dev": {
                "psr-4": {
                    "Syntaxx\\PHPX\\Tests\\": "tests/"
                }
            },
            "description": "JSX-like syntax for PHP with WebAssembly and SSR support",
            "transport-options": {
                "symlink": true,
                "relative": true
            },
            "install-path": "../syntaxx/phpx-compiler"
        },
        {
            "name": "syntaxx/phpx-framework",
            "version": "dev-main",
            "version_normalized": "dev-main",
            "dist": {
                "type": "path",
                "url": "../PHPX-Framework",
                "reference": "077eed534d7aec5b646f5fe01f36f71fad33bdbc"
            },
            "require-dev": {
                "phpunit/phpunit": "^10.0"
            },
            "type": "library",
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Syntaxx\\PHPX\\Framework\\": "src/"
                },
                "files": [
                    "src/useState.php"
                ]
            },
            "autoload-dev": {
                "psr-4": {
                    "Syntaxx\\PHPX\\Framework\\Tests\\": "tests/"
                }
            },
            "description": "PHPX Framework - A modern PHP framework with JSX-like syntax support",
            "transport-options": {
                "symlink": true,
                "relative": true
            },
            "install-path": "../syntaxx/phpx-framework"
        },
        {
            "name": "syntaxx/phpx-parser",
            "version": "4.19.4",
            "version_normalized": "4.19.4.0",
            "dist": {
                "type": "path",
                "url": "../PHP-X-Parser",
                "reference": "07e6f289522d89546a212fa59fe6f5a872967fb6"
            },
            "require": {
                "ext-ctype": "*",
                "ext-json": "*",
                "ext-tokenizer": "*",
                "php": ">=7.4"
            },
            "require-dev": {
                "ircmaxell/php-yacc": "^0.0.7",
                "phpunit/phpunit": "^9.0"
            },
            "bin": [
                "bin/php-parse"
            ],
            "type": "library",
            "extra": {
                "branch-alias": {
                    "dev-master": "5.0-dev"
                }
            },
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "PhpParser\\": "lib/PhpParser"
                }
            },
            "autoload-dev": {
                "psr-4": {
                    "PhpParser\\": "test/PhpParser/"
                }
            },
            "license": [
                "BSD-3-Clause"
            ],
            "authors": [
                {
                    "name": "Nikita Popov"
                }
            ],
            "description": "A PHPX parser written in PHP",
            "keywords": [
                "parser",
                "php"
            ],
            "transport-options": {
                "symlink": true,
                "relative": true
            },
            "install-path": "../syntaxx/phpx-parser"
        },
        {
            "name": "syntaxx/wasm-php-runtime-vrzno",
            "version": "v8.3.0",
            "version_normalized": "8.3.0.0",
            "source": {
                "type": "git",
                "url": "https://github.com/Syntaxx-HQ/PHPX-WasmPHPRuntimeVrzno.git",
                "reference": "6ba60df001006b73687940747dc1fdd186a718f0"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/Syntaxx-HQ/PHPX-WasmPHPRuntimeVrzno/zipball/6ba60df001006b73687940747dc1fdd186a718f0",
                "reference": "6ba60df001006b73687940747dc1fdd186a718f0",
                "shasum": ""
            },
            "require": {
                "composer-plugin-api": "^2.0"
            },
            "time": "2025-05-28T18:11:50+00:00",
            "type": "composer-plugin",
            "extra": {
                "class": "Syntaxx\\PhpWasm\\Plugin",
                "php-wasm": {
                    "target-dir": "public/wasm"
                }
            },
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Syntaxx\\PhpWasm\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "description": "Prebuilt PHP WebAssembly runtime (php.wasm + php.js)",
            "support": {
                "issues": "https://github.com/Syntaxx-HQ/PHPX-WasmPHPRuntimeVrzno/issues",
                "source": "https://github.com/Syntaxx-HQ/PHPX-WasmPHPRuntimeVrzno/tree/v8.3.0"
            },
            "install-path": "../syntaxx/wasm-php-runtime-vrzno"
        },
        {
            "name": "syntaxx/webassembly-packer",
            "version": "v0.1.2",
            "version_normalized": "0.1.2.0",
            "source": {
                "type": "git",
                "url": "https://github.com/Syntaxx-HQ/PHPX-WebAssemblyPacker.git",
                "reference": "fed4b47157e21b0278bf03489649fa71b074f5dd"
            },
            "dist": {
                "type": "zip",
                "url": "https://api.github.com/repos/Syntaxx-HQ/PHPX-WebAssemblyPacker/zipball/fed4b47157e21b0278bf03489649fa71b074f5dd",
                "reference": "fed4b47157e21b0278bf03489649fa71b074f5dd",
                "shasum": ""
            },
            "require": {
                "php": ">=8.1",
                "syntaxx/lz4": "0.1.0"
            },
            "require-dev": {
                "phpunit/phpunit": "^10.0",
                "symfony/process": "^6.0"
            },
            "time": "2025-05-28T16:34:14+00:00",
            "bin": [
                "bin/file-packager"
            ],
            "type": "project",
            "installation-source": "dist",
            "autoload": {
                "psr-4": {
                    "Tests\\": "tests/",
                    "Syntaxx\\WebAssemblyPacker\\": "src/"
                }
            },
            "notification-url": "https://packagist.org/downloads/",
            "description": "WebAssembly file packager with LZ4 compression support",
            "support": {
                "issues": "https://github.com/Syntaxx-HQ/PHPX-WebAssemblyPacker/issues",
                "source": "https://github.com/Syntaxx-HQ/PHPX-WebAssemblyPacker/tree/v0.1.2"
            },
            "install-path": "../syntaxx/webassembly-packer"
        }
    ],
    "dev": true,
    "dev-package-names": [
        "syntaxx/lz4",
        "syntaxx/phpx-compiler",
        "syntaxx/phpx-parser",
        "syntaxx/webassembly-packer"
    ]
}
<?php return array(
    'root' => array(
        'name' => 'syntaxx/phpx-starter-kit',
        'pretty_version' => 'dev-main',
        'version' => 'dev-main',
        'reference' => '736e5a60021e2e6d38948b5a00f9a14a9de77a81',
        'type' => 'project',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'dev' => true,
    ),
    'versions' => array(
        'syntaxx/lz4' => array(
            'pretty_version' => 'v0.1.0',
            'version' => '0.1.0.0',
            'reference' => 'f8e11ff917bfd4a0e5842d355020a562b395ce4a',
            'type' => 'library',
            'install_path' => __DIR__ . '/../syntaxx/lz4',
            'aliases' => array(),
            'dev_requirement' => true,
        ),
        'syntaxx/phpx-compiler' => array(
            'pretty_version' => 'dev-main',
            'version' => 'dev-main',
            'reference' => 'b413b2de4d4f4f40224ddf4aa78f0795230577b9',
            'type' => 'project',
            'install_path' => __DIR__ . '/../syntaxx/phpx-compiler',
            'aliases' => array(),
            'dev_requirement' => true,
        ),
        'syntaxx/phpx-framework' => array(
            'pretty_version' => 'dev-main',
            'version' => 'dev-main',
            'reference' => '077eed534d7aec5b646f5fe01f36f71fad33bdbc',
            'type' => 'library',
            'install_path' => __DIR__ . '/../syntaxx/phpx-framework',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'syntaxx/phpx-parser' => array(
            'pretty_version' => '4.19.4',
            'version' => '4.19.4.0',
            'reference' => '07e6f289522d89546a212fa59fe6f5a872967fb6',
            'type' => 'library',
            'install_path' => __DIR__ . '/../syntaxx/phpx-parser',
            'aliases' => array(),
            'dev_requirement' => true,
        ),
        'syntaxx/phpx-starter-kit' => array(
            'pretty_version' => 'dev-main',
            'version' => 'dev-main',
            'reference' => '736e5a60021e2e6d38948b5a00f9a14a9de77a81',
            'type' => 'project',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'syntaxx/wasm-php-runtime-vrzno' => array(
            'pretty_version' => 'v8.3.0',
            'version' => '8.3.0.0',
            'reference' => '6ba60df001006b73687940747dc1fdd186a718f0',
            'type' => 'composer-plugin',
            'install_path' => __DIR__ . '/../syntaxx/wasm-php-runtime-vrzno',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
        'syntaxx/webassembly-packer' => array(
            'pretty_version' => 'v0.1.2',
            'version' => '0.1.2.0',
            'reference' => 'fed4b47157e21b0278bf03489649fa71b074f5dd',
            'type' => 'project',
            'install_path' => __DIR__ . '/../syntaxx/webassembly-packer',
            'aliases' => array(),
            'dev_requirement' => true,
        ),
    ),
);
first blood
ref: refs/heads/main
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = git@github.com:Syntaxx-HQ/PHPX-Framework.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
Unnamed repository; edit this file 'description' to name the repository.
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {
			"since": $last_update_token,
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0
DIRC      h=K=g       +q         k|b::v|E 
.gitignore        h=|g       +r        ,]o\F?CazZK/ 	README.md h=h       +p        D4?,=X@etE composer.json     h=88g       ,Q        evp5= demo/app.php      h=g       +s        o2?WmdzPA phpunit.xml       h=#h<wJ       +x        ;]au$CKd src/Component.php h=hl       +z        ] ) xHn src/Document.php  h=tgL       +y        	R,kF_N3E src/Element.php   h=o2g~       +|        YCcKh5p> src/Framework.php h=awh<
       +v        (i[!b src/Runtime.php   h=pgP       +w         aFX<O	w src/TextNode.php  h=Ch       +u        U	:7)RYL$@ src/bootstrap.php h=,h7~       +{         T^c8wX src/useState.php  TREE   S 13 2
oS06src 8 0

u3l&demo 1 0
VD%+ =<nn+:N# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~
0000000000000000000000000000000000000000 346bd7345493d4e9b0ade3aead05be21bf61ad2d Bohuslav imek <bohuslav@simek.si> 1744729534 +0200	commit (initial): first blood
346bd7345493d4e9b0ade3aead05be21bf61ad2d 3d1a7401159c0c6691f9545e2c12119c81ecdf5d Bohuslav imek <bohuslav@simek.si> 1744739125 +0200	commit: first blood
3d1a7401159c0c6691f9545e2c12119c81ecdf5d 1c4c2d73dc81b4f886ca5e184db9d65217decc54 Bohuslav imek <bohuslav@simek.si> 1744739900 +0200	commit: first blood
1c4c2d73dc81b4f886ca5e184db9d65217decc54 48e7d701534ee11c99e9809e8baa12b4b2a593f9 Bohuslav imek <bohuslav@simek.si> 1744745678 +0200	commit: first blood
48e7d701534ee11c99e9809e8baa12b4b2a593f9 714900574d9eaa5fc61874315e98f0d0ab043e00 Bohuslav imek <bohuslav@simek.si> 1745004841 +0200	commit: first blood
714900574d9eaa5fc61874315e98f0d0ab043e00 cad221e57d819edaad12d01f239e9105c94f9417 Bohuslav imek <bohuslav@simek.si> 1745006247 +0200	commit: first blood
cad221e57d819edaad12d01f239e9105c94f9417 d91862e98c9d702aab12143f97b16bb102096bac Bohuslav imek <bohuslav@simek.si> 1745006647 +0200	commit: first blood
d91862e98c9d702aab12143f97b16bb102096bac 90906ad225d8d45c77a4f608484dbdfba61b6fc9 Bohuslav imek <bohuslav@simek.si> 1745007614 +0200	commit: first blood
90906ad225d8d45c77a4f608484dbdfba61b6fc9 c09089a20f523f59b08da38aa4d5a017e864e8ac Bohuslav imek <bohuslav@simek.si> 1745044161 +0200	commit: first blood
c09089a20f523f59b08da38aa4d5a017e864e8ac 0000000000000000000000000000000000000000 Bohuslav imek <bohuslav@simek.si> 1745960257 +0200	Branch: renamed refs/heads/master to refs/heads/main
0000000000000000000000000000000000000000 c09089a20f523f59b08da38aa4d5a017e864e8ac Bohuslav imek <bohuslav@simek.si> 1745960257 +0200	Branch: renamed refs/heads/master to refs/heads/main
c09089a20f523f59b08da38aa4d5a017e864e8ac 4492675fb66385edfcf768e634a7ca93fd80aafc Bohuslav imek <bohuslav@simek.si> 1748492170 +0200	commit: first blood
4492675fb66385edfcf768e634a7ca93fd80aafc e192a6d1c5c4185ee4ef2089a0c9f0cbf01c36d7 Bohuslav imek <bohuslav@simek.si> 1748492546 +0200	commit: first blood
e192a6d1c5c4185ee4ef2089a0c9f0cbf01c36d7 7d9b596637fe02ac0d444a651b02c5c471925da3 Bohuslav imek <bohuslav@simek.si> 1748492835 +0200	commit: first blood
7d9b596637fe02ac0d444a651b02c5c471925da3 758cedd00f7ee5a3f77994705b7c2b0d06df293a Bohuslav imek <bohuslav@simek.si> 1748792442 +0200	commit: first blood
758cedd00f7ee5a3f77994705b7c2b0d06df293a 077eed534d7aec5b646f5fe01f36f71fad33bdbc Bohuslav imek <bohuslav@simek.si> 1748801293 +0200	commit: first blood
0000000000000000000000000000000000000000 346bd7345493d4e9b0ade3aead05be21bf61ad2d Bohuslav imek <bohuslav@simek.si> 1744729534 +0200	commit (initial): first blood
346bd7345493d4e9b0ade3aead05be21bf61ad2d 3d1a7401159c0c6691f9545e2c12119c81ecdf5d Bohuslav imek <bohuslav@simek.si> 1744739125 +0200	commit: first blood
3d1a7401159c0c6691f9545e2c12119c81ecdf5d 1c4c2d73dc81b4f886ca5e184db9d65217decc54 Bohuslav imek <bohuslav@simek.si> 1744739900 +0200	commit: first blood
1c4c2d73dc81b4f886ca5e184db9d65217decc54 48e7d701534ee11c99e9809e8baa12b4b2a593f9 Bohuslav imek <bohuslav@simek.si> 1744745678 +0200	commit: first blood
48e7d701534ee11c99e9809e8baa12b4b2a593f9 714900574d9eaa5fc61874315e98f0d0ab043e00 Bohuslav imek <bohuslav@simek.si> 1745004841 +0200	commit: first blood
714900574d9eaa5fc61874315e98f0d0ab043e00 cad221e57d819edaad12d01f239e9105c94f9417 Bohuslav imek <bohuslav@simek.si> 1745006247 +0200	commit: first blood
cad221e57d819edaad12d01f239e9105c94f9417 d91862e98c9d702aab12143f97b16bb102096bac Bohuslav imek <bohuslav@simek.si> 1745006647 +0200	commit: first blood
d91862e98c9d702aab12143f97b16bb102096bac 90906ad225d8d45c77a4f608484dbdfba61b6fc9 Bohuslav imek <bohuslav@simek.si> 1745007614 +0200	commit: first blood
90906ad225d8d45c77a4f608484dbdfba61b6fc9 c09089a20f523f59b08da38aa4d5a017e864e8ac Bohuslav imek <bohuslav@simek.si> 1745044161 +0200	commit: first blood
c09089a20f523f59b08da38aa4d5a017e864e8ac c09089a20f523f59b08da38aa4d5a017e864e8ac Bohuslav imek <bohuslav@simek.si> 1745960257 +0200	Branch: renamed refs/heads/master to refs/heads/main
c09089a20f523f59b08da38aa4d5a017e864e8ac 4492675fb66385edfcf768e634a7ca93fd80aafc Bohuslav imek <bohuslav@simek.si> 1748492170 +0200	commit: first blood
4492675fb66385edfcf768e634a7ca93fd80aafc e192a6d1c5c4185ee4ef2089a0c9f0cbf01c36d7 Bohuslav imek <bohuslav@simek.si> 1748492546 +0200	commit: first blood
e192a6d1c5c4185ee4ef2089a0c9f0cbf01c36d7 7d9b596637fe02ac0d444a651b02c5c471925da3 Bohuslav imek <bohuslav@simek.si> 1748492835 +0200	commit: first blood
7d9b596637fe02ac0d444a651b02c5c471925da3 758cedd00f7ee5a3f77994705b7c2b0d06df293a Bohuslav imek <bohuslav@simek.si> 1748792442 +0200	commit: first blood
758cedd00f7ee5a3f77994705b7c2b0d06df293a 077eed534d7aec5b646f5fe01f36f71fad33bdbc Bohuslav imek <bohuslav@simek.si> 1748801293 +0200	commit: first blood
0000000000000000000000000000000000000000 c09089a20f523f59b08da38aa4d5a017e864e8ac Bohuslav imek <bohuslav@simek.si> 1745960267 +0200	update by push
c09089a20f523f59b08da38aa4d5a017e864e8ac 758cedd00f7ee5a3f77994705b7c2b0d06df293a Bohuslav imek <bohuslav@simek.si> 1748794709 +0200	update by push
758cedd00f7ee5a3f77994705b7c2b0d06df293a 077eed534d7aec5b646f5fe01f36f71fad33bdbc Bohuslav imek <bohuslav@simek.si> 1748801301 +0200	update by push
xUn@9Ra(QS*oH U*{pvzQ/83gLfo]"	VhLO?(|J2Z/Y rWT3(4<BdX0y8.G}) 0'L2	T'RK_{J,CR \$Op>LWWlh!u6
BeFOjf4+2t(FIH1>PLZhM4\5mr}:!M+	gTx7Q2Opn2O
oa j9!LLmbA,(i=_\;bT&n|CK0}5{f&ZqHCHhY8b
kr<^zi%/RdRrnZ**_Pz?6l{R\"=i9Zb"a$FxXPJ=Oc{8Wwy$KbW}	Go+Re,R5F\~dv|b-H3wnFXYpmnk;= WxKOR046`/(KM-.HLNU+I	q+e[%d)$jded&%jrUr) AQjIiQBPi^Ifn@CkbA.
xKOR0dP  x?O0+;26!6*4j8_h"N.~
xn3
#'BcI|UO(+ez/IRu8):f:J*4[@TGY)lo3|<.VIR~1#Im2e*KgY|QV@PZQ3K: dv<gdk}0s>-[=X^{{	<KxI
@])^t74$eeT*4Vj56uf&`H#v$pQ#"melek,hSa^:NeXK1N|}2shm*}'++RJx+)JMU062d040031Qp-K++(`g`)*.s;B\B
42Ts#y_sI+s%@\=g
UVZ_Y*</:n4TaPi^Ifn*XQrd7IPe!%~)u]nWEEGKK|f>UB$@d	=.,|* 'H x+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.,K C?z?:Ti:'[	ui=~PenEE`{azvM_	AdjK&z UZQQvP[X|YZ>.)?( lPN?WiWq/TaiqjpIb	eUw=ZbGE6 x+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.,K C?z?:Ti:'[	ui=~PenEE`{azvM_	AdjK&z UZQQvP[X|YZ>.)?( lPN?WiWq/TaiqjpIb	@O}KRxXmo6g
fm}CM4	l`,3Y(*Igl7jlw=J.rA~{[VAi]	%7?=gc_I56tT,{9%+K~5-Jc%$,krBfoJaX'-I(>T4yw\Weot}1{o}(r?i)9$ym9h{FT46t|x4G`JR@7QaLD(}\}aa-&(J\$%Op`fKZdHYRE(6\}<m;Ttc))';DzF^uGo(6@;hV\Rb$+.Ef]7CO5Nr3HT}a4.VR+9=G775_M8H%AF%Cgj	>q]Z)j{!Hj7FyvGKXG,uE,4f{zOs
?"1p}U_	k'xQ\cPa IJ;pYVyy9b,Reh*bvWC\U7d8|U:`";}%ehxnG};Y)?#^_$s5
}
=+m}SS<zM	GcyLRC$UzZ=D	beiy 
mIV1$P87&C7t[#v@{)	Xm;Qq2
lhj| jM--ma[.N78Hr_!)<a3F1[RHzdZ>:ZZ5z.uA`#ev'H,_|t&[BC!luW4 RKI]=*o*,k~qi9;;j
MZVOv:B2VP2%jd9*MqC)tcBc%PfBH	#9K]dEaxSj%S"L}_<e )	J0k.P`
sie;"s1F*YOiGAJMY"gqM>G-sD K"@Be~E/u\NZD  -^{s+	vX+8:m"ZW&I%xa&pk_,u^Fw#mvN[8<RA6P8D,[`.b{@XFd=^s;w[z5[xD|gr^:tbL;2L@9"gjMC^0\=2m$,Kx4E5$5N)0j55C-yMJw3wC?Bx}TKS039pAq#C]2)S=eKJ*p [h8|]zy
woII-$z=i%C^p%fvt3kFRL	,2!*lq9*^2Rf^\\8IXF8'(dD=J.;g^:a[}	h:B(=Ih:>'Ccg9B(d7*ytyF
wQMO.oN%8+46NH2F1}'[6J$fJ#.e5~buu||kxq@wDQO4+!t1e/?}E`3O|,,*O8,X*e3|`&D.6MB"3tJHJqdk\hth=8x=<(E[D/9K*mCx3jb?KQ9x}UO0J<)RSt#@*A&Kvd;P.NRIh|ywdvDb:)#/
?KAfN,e+&L&XXOaSRm\eRX8w_pJ<\jrBP-j"akX+Y
%<p)U0o1K@4Kl3Db_2.HQ)Q9u4=:Tm.%L$YeI'LO.G,ct|h7*,F4ss\<:}jEpy",O9Zz0H~ZL\:2 "-bA& [yX%3\UfJfxKBNB=i;SH1kbxeh=I@-R*!f;GbkfN`8,`&";Q4PruT5szmphj[6d" k{0oq8+&;8at{Asxh^8\RN+l"9+Zjr7fxVN-$w|L&?>2!yfvLhv"|lxEQQ-,,_=pr%p,ZjZgxYmOFg~6.F}88H U%"$.k^wfwu:33qV/rk+.EOO',[[q5jrbSVC(	`3:9,biLIO&n>MU"WL,8E'YWtz1VsMH BX4y"BfW +a@HM	Zcjo/h|
RQ rv;aL..nFj+3reMrD2E.hbb(^C$
mOk27G_//?+V	%X'+ZSF=I&5j<2iFZ,zLtSfh#T.M-Uas^gi{G*:hyNgnwZ3U362|8~MMq*M)DW3D}q&pz(P8)&4nY| }7$U1L3NPRGwVp>,ScfzI/5!EB oCdo/?!RbVTYvo=ew]NCI s77ImS}|
&RgrKw&Zf>jh&[gxhh0H	'M0TTaAd{)ea4z]:@RbGXlCGxG$NQc
YM	FOX%b`^1]EMdh?By7V?|E:z|\Ix`qVT"G9NTu:i&VQSBq1*lYNkm[a131[b*qb51FW`F--R%HL+i:[Ci]&_z\Vb0)dU!x[|5$PIeq(\ N"q}I
%"GKYW@h1wr[1leJz^p&z$,nE9
uI4YTaGDGAP[B2q)7T>{.E@S)6ee{DQH`>E$njVM&pDLv9nXC/budr99,K *Km\3pp_vG	N33]C%Ryw4 E5)}2*1qMHUz>F-`A1]c5TS(	UKj}|XP 44VmyLc
$(P\+x	Hf]6+AV*Occ!q[D_}^u%pk7dp?,
VG@4	7Z7Q,=]2O_vP`9V`kV*K	kt:	Y%pBbU#/E&?;}+CeYa2l-K("H5=I/VEK+BQN\q=iP.E?i4\ yK.yW< Fu
(00VG!vEx({bZbG9(d(i.EbnX9l L1/1S(XsoVB25,k[[T*0b3d	S_ox;]D0,
G?dDI^%EIBMtTa1=&z9"j7",*`Y6T8\!
C@;L(,%.#;g)@t#:bPYiDdi4K,r>x-icghW jc2B0s[?q{?}!\OA/U $IBuwOdFRF- D?{SW#uY.W%x+)JMU00d040031Qp-K++(`,Q"t5+4-.*tO.;U\?/|M{%4@M9}OeMSWa3v*s+JM-/,cnkJ04$37L_+N|:Cc5,
.""rJNYPuI%%E`rZlJ3tn*{r,x]
0})]4]onRZl2*o`$XAG6Enbl7#{(VD
"cAiuIi"E:<zse<ykaF=jD%59WX
sToJJx+)JMU023f040031Qp-K++(`877_X)ABlGwr-yg*PAy%`eL-'@x-?I,<5857)(3%a\e*e_U`j@u]y+uk|dbk&N/q7'>2u>U mx+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.;U\?/|M{%4@M9}OeMSWa3v*s+JM-/,cnkJ04$37L)n&M3i_uPe!%~)u]nWEEGKK|f>UB$@\[uKUQA/yz$Zd xMk!{?{MmRJOH\R28q%<~3HZVMGb=imv:@jW!YHY;a	g@;mn}`tIN5;1N:IF9=}Jm49Mv`8TdgZ(ep@`+u}`c9oSxXmo6g
*M4Y ; K-DT#)RewQysw<nd~=_^lh!%oo??^/L 2v=aYo):)x8/eKA.[hiD@sHX2N&2I]g<KAp-5](3)	dYi,%!9Tf>8'MBk'Fs
nint>O'w!}cFQ^Hk0K!2ldbu\,C,u2DK["<'!X52:&=l.%]]LhA9I,n152jMFe+JiHM'
Jb"<:xNh3b4lt4nYgkIh_3M9lv{ [Qz'"fa$+p!\LmX4)KW3v&/@nwy$^\	!uK0pb0Uq:0)i$:\k7gYHQ(TA5@Y\,x1}R1y>mG3q<'k{\sPwT7$.6
[bAD-'ye	SGDZu*nC3F'.b#R pE)n 0iMu:~8/V!q^]d~R`<Kaexq$USZiP=,2Q PP8\v-}btf2bh_%64tI$KCLrroc*<JL	qwSo5z+5& ?{!
"n-0quDpmJ!tq66V$`kSXuq0lp\@{J`R,X$Fc,+NSS/X3aH :XY)>:<'Nc7y?{^	p/rO	L?MdA@`"5GVK k"MFZ kv`{@Rl`H3@D[;xxbj#SkGc5P@Q{R^VN1:T5>~4Iv9>^r
8H;Z*-_l+@syi/^/NVVE.'`lD
}'1i%LH|LP~@75m	CfQ*/X0x_K0};!8 Nd&`{Srs6:$Wgw2n-Vlet4~>g|8,I
%'6b,2+8B>Qhybd*nVd63Lm)(NI3"`|)cIwP Pw69;%vED^BIf^6aMN9qjQ?z`VQO"j4=rs,y-Fm&z6v#8S)$pM5ZzYXPPM	gRP+uv}G}P*CHxMKA=/?=

B=\nJ"N[OR[}~=K FH}:nb`i^
cmQ/kxU#Bj V`j{|pOu%)j<gY_s #dh4Bq=nt*RGEF5KoOycZ,
MQL)
1Yt	6D<X1/Yy_Yg,9_xA
0 ={$Y'iKd{xaZJVp1 902$>[$h4q6ek|<\>HG{;U37[WZyrv=x+)JMU0d040031Qp/+I-+(`#kv7	> lx[
0 )_xMHz/	<]_f9Pb#Q)
3E)J >&4`VS.V1{EI'Ak:m'_eO\VZ4Ai{weiTk.JxVmo6 We40q1lk(%HM!#E)/z{B_U)OONO$d{i|QV0cyvz(2XfELkqp2whbRI.m[dfP #!Ow p,W;XALm;N	D!kd9|>?Z?,r!LG	;1ia`QVB"9$zy|gX~]NWCN9XBJBaD?)8j!X\J=P;mo<mv!]Kk4?0
Y Is=$a4Q@G$XjU9D<$uXJU2"V@WY?vz#ikyjfHkZkj"d	L1K,/n[t'%\l2^>a1Ce
_'W_r!BHgNBE0Ut|rwg#S+'4No}U \k>\-~ad^pm1fiQZ0:;O6f>m'dqs{LwBj7u
qx>ik;SOqjq!zdGCPdo:n=Fkep wLv'ZoJ>>CV<;x[
0 )_[oM6h42Xyj`,n"D>zI;y)D0GnAg}? %gPpBm,f9~cN#!l lg^K?xZmoF[h$PrCjlpxH/SA3;FRN~*Q1Y1g?xjspGk^m/y==M?}EytpgQU&5?0x6eeQ3y}|NcO~V{>w/Z<Ou)Kr`QduzS@1/{tiZV<L/?mN\I\yx*X&.9h~8gAG8`"Aw7wcbv}uu;?^mfuSKvNhCfMlYM]lhi:	/@;cZ}5OW/	."%ugd9FjBjy\VQ-5jkN ]KV8F9OMYoiaGd*ZsG4yyv0vxF%^gI>BmqS`7ClZ@`&f)mK,!K\3DVQdgnK3 TZQ]os9Sebib`W4RRRA^$.<DD+<M~mx"%];h@KJX)`GxE&VeimIy-b(f|}^8d[*9qkX G%}M5	D1ed"<#[cq
HdM'sYM	GOX%r`^1Exdh?Fz7?|c= e"0t^z`+(yEIsfRu:i
ck)q,M6OSzM-2y~w1Cg_RBNsa
Jbc5y!htEC M4U,PNXe	U[8\9*4h	T[Ho?R>7+`:2+_o7;+6Uy]	H:,nHf*V6<N,^Eeetrs1*DQ&0>{*.LU1;e!QX32/bqSddKt#5H%Ap>!n!zSc\}> 7PWS5:HGBVZZ.(DL:iC`E=o"`y	6R|d1VirbgCE1tkLIP= P4YeC-8"*,rPJJeI]qMm6LAhsL4C	_[9	/-NxeP0 |9Vb(yqs;SB>w>}"aNr#jqzj9Ho<HyZAoU/AW+j,u:UC4n.lUr#`^
sN	M21'e ADm7N~>0|My&OalOD[K8H&PuGD&W+_f-CS 0:l+3R<U%NW&P7ms
*aX',w[[jL,-1JlR`@rS}bLn4TYRgPs0VnqFnx
5H5ERd6(sF 4RSjO8l(1))+[C>,ag-y#T(yf}'0QTwm~R ]"nPSL1}wR?b',cmHq$%W'tI} GU	B,v)Lxk"b+79P8MC{A+,u|qZ+,?	@R0uejr @
7k2SA+9Y%.##
4~Fr,4"HZ;{pC+|S4;:O(/^x' mW*zN[Y	e`/Y-l+{Ztw;"BRK
SFR[!ZaAMAd u*
6Ii$cf/x[
0E*_dwL&iq3sytE\*J(X<Yu\>7mhx)dg;CY-xkC]T:;<,gp\?[B$<luod? MfJx}R]k0D=f{C_"bn$K%j
s=lZ{=XpV!bU@&Idn8JR$L-cr Dy$N2Jb1$5 1sP\:i
tSjDm@(hw$Rc5gN07><2!?roQaPVrAY@VM-[Z0`D0stqng#Kp`p~[T`Ztm)*9TnV29fAAt
20{F5-[sXH)|gex+)JMU062d040031Qp-K++(`g`)*.s;B\B
42Ts#y_sI+s%@\=g
UVZ_Y*</:n4TaPi^Ifn*XYHa*4T[V|#TYHjE_~
D]bCkgnbf?'k,sC9|6_t:rO_P%%YB?mKn;1;#/ 1=x}Uao9Hj]ZKE^
ItVj-cP`~yf'x?U-nlb9QM.&h}-K]* \Y'(H.YqBAcwb0(MxV}) 3L76:NncJA0
M)hd-pd0)Dl'q8mh]56	\n
+6ZHj `A2-+G53DeS-5Z	hov;$H$U%%DjnhC	`"r6v5Y[jmwC j.pr=S"$yJJS=
{?'sN{:n$'
6XQ4QJb+>M"G?v@n8
V['E-~ =u
RaB/]qnZ;4`7VOv3	R[- '|59Ne[BcV|	]08IThTJEv>gtE?[BIFf 4%(r>f6i&]gWxv<LG5C9
eC1#Y.Mp0(EUwFv)Bnvly3]nnRz=m}30vsn-IoSj&ByxtuqgDSa C)B54xZYoEG VOk0clv,CEjyXC=U]}=3<E>4+|G^-_Nk|\Euok+bWM^,,(>:YIQ|>^4y`%qS
a.7`i5JIUC8M6MiMR4}*\a*]/'Z<5GJ_>]'d\mbf_.Ym9nL"4%'CPj8|u^6#Jm#cK7_./.HA]~REr0DpjMy\OQ5%55%`zl3V9B)Ob!*'IX+K\7-=9d<*34 S;y3CMVKy}~.AoV8!B(@Q?	r^krYW-,!0/E?`Gy),9'jAPQc)<4;=/<'rpDYuo/Q("( i~kp1v9iI<YfY~qTz*bi=g`ht<LMyp*wwI$pDea#vEP.>
I
i}\|"?"W9wEi4Tx%m=>Edhfn(z{~`
3?~F bG_	EjjH9<{#KEY6ntz(G'eL@W`:'AmQm2 =#B8@+k	O9HU	t9R(H? 9yiq DdI1S~m	Z)YJ{@-HL4b\Z\)(@sQ(J^@Uh8mc?j)NVJyL+$b`ho:l0 AH]u)t_A/U,C<9$YI1-7U,!P}(\DqKI'c4xhF	M$E	KdNo0!3Ua6)JyH}"=N&yUCgl>	=d>{73[yXjviWbqTb}tw}cJ:[rQ	o:)*[HDu*WO:tuL0s]hbQD>P j4yTV)r$=s|/Q]Z2{E6kp0PFXB7U],$g9/`Q/rpbIKfb47< bAU3 C(1
*i/G;)5(
Y)`Ok(0REaoCfJ>6#-Aa_b]
5U%t`Fc/5nX-yd56o`ke4rO$LiCphn7sEidz8,R7^|Q/nzCc>&	|2O-.dct'MQ0 {G_9W6?C"V	m(u"fN#9%qe=<83WUCC{X]*[#D8~[H1&7L^:sL!gK_ YD4?4{6|h1]N?`_XqfkXe0/tx}n+^p0(<Y1;=Gf:Z1iwp&p+R&z`hXY}#=B+/jJ0 ]lMj~xf	>'Ng=b"+CI:z,^ dQ1'^B*[_<	mC0vk	FzkbD9=<gPfUQibyj-Y}ioYmQ,5Mm+&+%hlmp%<qh^mB]%,	 [S6\M1|LM G)rMqzGXu@xZiTs#E5 .'~E}[j7o
I^AY/(b}eVb9vmEG,}g+GW6)TO5pWv J_=v9u"^Na4b4 z]+KUhv^6Tc8(ZxYf3idD^Tu0$t)an,t]	F0GzsO(3VZz#QPt!'$Et71)EXuwO:h;+-
i&@ELs=2oG!Z f$Bx+)JMU025d040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c`J9Ys31 |5VXy.[nZ|L6"Z[Z`GC._8 ktUy%z9K'7z47CU5=!&%3)_zHf^  De]xXmo6g
jMa>,M<tiHv!ci%t.qaF&ys2/~_hM*)Riq}~Kvv0)xbC)	XYivVj,&ey_2}S
"O[1P2}h|r]YUVseXAvY5Q5E 1 TRwDjS??#Q,<||pvuu/c7xvK;xqY MX4&N mDKtq`ZdkcOWgmnC25'\#Q?BQDJ]a<L:u-$P.(W#fJ90ix8\&sh]iN#&VIV~ ?FJ8Qj%|'U3)[Q DhY>v63^% LA%@z`(vcgwd\s	#vhEyFvX)x\V#[2u/~;"`Tq
0@q2\E$nj^m^tX;/Ov*g UM).p`t6t>A_|_(&|}GyN2:-{Ph@$=6f[JyDENjnAN&(`hr(%Rqe#	(*tT
S2!C7t3E>]'Pqf
hQALG=#f";K#[88$._np(F$(noNEf,0>OBP	~}2XM-~-^2\M2AkZ@2;dzi'02ngDt/|}-.\?c02nz	;GRP+AZ+e.eJZhLH=Ibo	s!H <8t?D
}VE%ol&'|b]{SL+vYCQz0y@+tvt*qOPj:;,k^z!( e-iDl@dpM5-Jr8T9%N12	D	\77E!tA9ifA
x7j{W@cfWLdUk~Q|jA+"-qY7HPX2rq5lt bS8zbni<;J -V+*=n\z
AF_+zE =K?ltnn/_[UkntPo]*Ur" 	7uSU< c{gNOW	%I	/]|w9RfEt;O|^i4aiAK2MxuTo0RCa!!MbZ=0'4lg{sCTw4.FFbZ>T8/`8H:m!3#REWm	UABlud]U;62xE73|Z1i+ic{Ui;-?Y1PwlW`i
yKc\e2W-XF>8KVun?|krX6:[p%mQFT](k!u*CrkUqOIW{Wn.V&5PJ$o8hN"T$zRJ?\<bcqr:.T_\pq\Dtrik:ql:ej{8?ovq4@:P7*P@-tX
Sk9hl+Rs ],wy&KiBQ5'[$@v4~BPJEsDgmDKeRhu)j'}F.a\![ xcK08"Q+Lel15p-b3Di=}9}vM{]PO:k/E6_0/2+*w1XqL wxO0=?8QL@B=-~[L./oUt;! 6jl8y=X]&x;#4n,GRHj4d)EfWyY8-Psa:q:57^6
@mAdDQNPYA-!64&J5}55StV
]^+[>1=KZEJ;Gj/;hY/m;D43lplRlA4fIETkx]?07tMC1w7Wq^^`6	0P*a\5Mlc~2'spI3P@^|+\+R+2C[s}x?:n",@RZO)P<Ac
|$x\/nNMx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c`J9Ys31 |-a,.rTw~Mp3gO5 4/D"7aiF_|
g#d9AT~kt  XYx+)JMU044b040031QH,(+(`{GozK;-?B$tLs:j%f=T%,3/%B/$7A(b^277?hn `-x[
0 )_M'7$[l2KOLR:w1V!gGp+q4)H$UQ	m}.uzp?q^?|X	Q{-a
Qd?s1vsYJx+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.,K C?z?:Ti:'[	ui=~PenEE`{azvM_	Ad*_a"*Pe!%~)u]nWEEGKK|f>UB$@d	=.,|* Tr<x[
0 )_ "dbkM=^x?g``A3DEr)gS}Qq%b%P:KPYj$YR#T-piNs
u<
6ZJA!OLx+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.,K C?z?:Ti:'[	ui=~PenEE`{azvM_	Ad`};4CVCV@%v]=v)+mVsK/).)J, 87gUA#wUqhUXZ\X1%Dc_h<b Dx+)JMU00d040031Qp-K++(`-.I?0%?4.^Y`MGLh<5'l{-sor+T[Qbnjy~Q6Gwr-yg*PAy%`es>UZQQvP[X|YZFR~~IqIQbKs_2_g'3* qxX[o6ga}pm6&HaDZdI\fEN(<\E/_ueEQrivuz3sv,udC{OS<')o<IDIO$dzM,O@s7IT1JAeU;7E~bMuMWI#M{FjL8!=3,Ie0S52"U ZZ(}0&%Mk+WqN#C`>__^;-1+${2QA!M[-^eCOt#5ox-l./.| u1) okZRN{rYdiE"E:av=fI.+'&Jay<6-D"4qp:x	e@(hw4Is`-V9VoRJa6nV	ZhY4Fhx~/b&80#7a	P$s,Y@h?Amr:9V@rU~$0 dndHZFk2Ty$23vb: Vz"vG8VF+o@~s6OpDp]'Kb?r8 :OtmA@d+KNAD!x%3L^37V4J4ZtYlq*;K@wE4_cT<e&TeJiP	.;A[*2)	IT<`-+lY!YPC fkPaQl7au-3wB!qe&,Dm|*^\&+g|k=ViJRd56Pa,|]1*>cBKVTgRN>lh[jm[O51o$fh*o=jvW]0 =!x<5h_@>,yve<;A0lVM`z=!	,C[@	z&}Ix8PO,\Z:$}OYPFXI;Fa-B_\}-AN)GD_h@zpzcmF@hr_lztV&nn3	p\v.Rx>0y"/[}$H0Hrh	Bjrf4e/l(?Y,z^9yha_J6K]K1B<&fdchTISgMn%&\rni6m7+,&9C{f.ecuE`vS:.%~;Zs$~@h'R z1r(@.M.(yRr#b2&e'^=\\9pu^Cjc,"5Gk Dc-`g,T8J'xh%OYVA1XOhnYZU6.zo~<.56<v=_W ]Zi+W8L3@(i)}!Wo[iDMMoND?&
AaBt^6|H?'2u&dxK
1]'&It$e<WP,scq
3CDk1RPr)vXB~nko4i3w,H^&;QM)Ok;<g8 z;l[4'+Km/9'gKx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S|&gxf3NXU' 7YxRj@@0%KR7qHB,,Mkaiw5%YIiB{&8;|t~u\G*NVa}zb77gPR -+AYAsTEK:WH
Eeh\dJ~#g%E}_~4RN&7jo'${A]mcJL%XG^{a08H+"),a:0`&>Z+w@DjpcCbzX9,1`O4ta5-yOpb	hxp1G	S(I	Min}1Ih6I!N5&F+YB-Fy,N1# /?x+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*cz_z6nii/LL@!%57aK_}wfC)((,aX?h).1(Au3,D Xx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]SnMn\P#vc{ Xx+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.;U\?/|M{%4@M9}OeMSWa3v*s+JM-/,cnkJ04$37,&$!_c"UZQQvP[X|YZ>.)?( lPN?WiWq/TaiqjpIb	vlk!=9X)/  O9xUMO@9RZ# CEKR-UMrXp^cR6naIt;ZLeXRX.O/iUfV<+F4pQ"UOn|slGn'MA!0B{IXt+DXL'rG{wWLf(PVH+nB{a.!(0p,4Av3_ZR8]B2q.
X|?%jk,zz6']>B` xLE']9z.p''Y~1IU	q"RYh$,K_!oy*45`/18_nw6Fu;Y%;1=8UC=QQ8lgi0.$1
o9v+L[@+yCeVU!?+UDM%lHka!WH%0( 2{R4)}h2$m({^nXvix|A)k=iXf{p%x&fy<VX^T&+G ?/1X~x#V	'x+)JMU00b040031Qp-K++(`-.I?0%?4.^Y`MGLh<5'l{-sor+T[Qbnjy~Q6Gwr-yg*PAy%`eBV\gXajB/UZQQvP[X|YZFxjcqqjnRNSQfJ:DBBbU_Wov~$&SzKK4GX%>~f~2\; x+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S,oj6c=cr yXx[
0E*_L"N2y`k$I]q_Vq~{|YA|k`T~0fLV0JD$3(G[`(6h.#(d5"B.U<skJK6yW8o8Z>kFRq,JRxmQJ10n'AZTPZzH7c7lR[wvC-47J6+88N4QVaSmt7lF#xP
&SV&}Q yq-Z$YwJ+&] g&;MA(:mSFPJG%N 2m5U(ng}*)S\"!9P\.Mj:06T= HO$=,9n?pL$5]UtDhxVmk0B-@ck(km!0HKQl;{KlYwsw
|o >>:>yR	DS:L)3 W=]i<~{iU3X>?{|\/ U(<X"ER$?B>$`7?XB+22d"oP\<(S>&BE^kHUC2| `cS]l&cXUkp?
qEzUXa~hY-c.s;4>:bW"CMKyCdG^JM5T'z(SUzUnBn>r|	0sF]N`VS2lQU_<cla1%wteQv6O^iY|rP&'M\{8F &>sD3FFzB~u$B@`cLC\Fl .3@lzsMFl{C7HO84pY/0&=K^_d7`w4eZjOf%,C(ENffPTZztuJ	*;?qM.^]gHQ4D$2cx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c`J9Ys31 |-a,.rTw~Mp3gO5 4/D"7aiF_|
g#d*=|f'?4 Q%Xx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S_ 2{Kisn2~ Z7x+)JMU00d040031Qp-K++(`-.I?0%?4.^Y`MGLh<5'l{-sor+T[Qbnjy~Q6^gdd^/xw]WBPAy%`eW2NqE}@I3WEPe!%~)u]nWEEG0o$%4l|Z3#%*u Z*o	xVo6^T/SH0hILrYNo-_H{=fY%_un@V42ev	r|)gJhD`9}Z+^r"a~X
Z_J*e
B*Gf"v?G[0*60eP3%f=a\'^LKHen;	=F`sKo6>gq]wiP8Z }<|9/4J6MG^%#L.ol6,UB|y:UV%x"Mwj w0w]Pp@j2o0WTA-iY UF\UV[}3af"k'$$
xl] fbi&I&Dh6a]Q@)
H]]<X@dta> %^QvP~EwaE?0VACx)K
c"_OS+05{QISA.xB:CB]@]x\gy]m6tzvP#iXE Sj'Z(KR)Q,k<TzW)i}b'RH	*~DaqXOtp;G$x4g[q%4~[K;/@Ea	5,5~8[Dwmz=t=?'t2*x7yT/#yJ0I2CMi|}3/XU{B^hsl:#[m;}~L|7H8p7Vw_G9'sgv,"&l1?sxU]o03RBJ*UtV[MUj(B&olU];0{2j''>Y~8hH6E~)-[,o?x>Wf|18G	4@OYc	0ZztkcZaq!n,+@q	BLlbV+Wg:w:N6c]Ut:-'1v~eRSA'
&Bu1vT;qw|)4jC8<q5UoQh-ABLf~A0 4NN/	CPg`M&i5sx.]-jv, ,9	\7+cwcre\"R.R,LlzHDM)CQ0gfzINx\D49i%	lQw! QqBhyl2oj(h'"O))1:\-H\P?(pn`jb|<Js #X.$)k$nRQJuv\. N
?\M3dxuR[o ne1P-{pPJRjd49$3	z~|RZPF3<B&Un>{h:)/r5,jPTUTGrs\mILip\/r%\sewmF(
A $t(Y3\JKxLfx(v$dNBOQm=m.p[~j%r`DY7pP5m#X_%ek0*yV4bc:(/3B]?xKOR046d/(KM-.HLNU+I	q+e[%d)$jded&%jrUr) AQjIiQBPi^Ifn@Ck .+x=1  @g^(:ZFmI$B#D'tj1Tw_@9PV~R?1)x+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]SV~LkX
sW% Xx+)JMU06e040031QH,(+(`h>"A?.0mA ?xUmo0g$'E"ZmLIPIB0"P8/$=</X,O}n$(:7?%,EqKf[v;D])q:[5GJEOz#FK2lZCo{
gX"jH3I$)`Aix@WBN$yPM,J4f-@@AV)KH
DbTnGPL;,@-eH~e-xI*q
@,
>y5*1>0IpCD)`}7%=Bl@Pwx*	><bEJuo/%XcVF:Z<?"Q$Trg)1CLQv	C!1)TS39+zGsfc+4",`&#GBF"G@X"'ZkG)2s	4/T{\8,d6!plV#)E'=SGUwn 5MTBfJ t]&:n~L;?'3u[fMi~|w,zabk8~
8N'A=OBb.[~vfeLrapZ9xK
1]3&tt$e<WTKeY. ^e gEdV5b)[K!(akF26y&;h(RTt9kJ2w|>}`rJnA=\./mLVxZYoFV * }IDEbl(`E%6
7i*M\;;yz_e+^a?>=*]^~zaU&Y0ereoSYySaD,8?Uh	OgK,AEY["`bZuIUKh5JUI]	i^~dQ&6T2
>xz#><xah%H;=z8aL.fGnwf	ml,K<zTs-5 -B'(NXi_ Mcllasp3Hpc^s$Kk=.:tQ=[9C>o4_z6y-hk.HZ8vK<HyX
a@Uh;w<IWOa7[gD]rn8/UT#]u	< bjiwjE5;RY YBDXaknKc`Q]'PA
|[^2++M	 c~
u|sGn"m;%DJT4=fU?&73mSAFb^<[	zE'VYimnPSGZhQb9
?_2.3PaOj&bL"O~]Col F(Y!sr(EFIiGxbdNPa<!(/c+_b.e`b.Oh55<>~*7P?|c=> .e"0t]z:g+vSj)S~uDI+LK1.cd4yloQP:#
$vVZHHx"D+Lx"b'am|PEP9D\BJJGF{L}Mdc|6O!^4)BGSI5,PM9
U$LeXV6AG 0xUY%2Aa'[ 42U1;eP32|e*Cbr#5(%A?C [lJkW@%@%UTCKHGB!\PYtrp{DN-
lW"\EdCE1LIP}@4imC-8"*,rP*Jt;mg]G[0j!(^/gi6Ge`:U> $&,gN(jq.bTHZt-GnsT?O5)Ll8ig?k[Y|q
(6&K`,N.QK!I<%O$7l6?bHj:X7WPX\%`'+3EALc9 qq5 $9SWo!g3a{m%F    ==+IK,/u
q;pQ;7"]hu^K_nU#o+H5<V<ZXlo'{wb5Uwmo#^Mh@Bp*Lp
1N{i
/{IUp$/:Bjs n[>in'!fiC1(k]K}RX`gM~9QRDHJAw2?S 	/qR(Mlu&tN:Sk/Wkea:+"CWP
l>Yq(Z7!5Yf:raZ"'sf]GC	;Ght%'pY "kSR<`u_Q;_rpPbo1xme&aT1#RqVx:tW;YBRs.QFR[!ZaAMA_]7M=:r9\7oW0xZYoEG V!XE%cTuwERnvB]WGWUkds|gwvp<8}Iy|;;Q%*^O^aYPdYu5OMYU ,{(!|o_?K(Ei$[e<Ka/*^[h6JT-bR3N*VaHxqy.Iiz  D-*8.-6g%OW??<xaJqCl3A&1U]K6;CiEf(KXudiT-YHm)hid^mGH[=F6G_NMloW?g`)FJaB-p2Of?<f\5%`zr]dKV8J9SE&.{RvG	MjMq,xjTZ'hK@B~]v[omA8C	5=g@	e _	M/5Ade IBN3x*UR)kEnKNp:@IE1ND-WMy	fO5:[k,TA[1}f)xWuUei8)xy A>w	<2fdC`]" -1/zY6HO0IoKW+G
Ql&HG@c>); >'?}[nu qIIEFU2fc_ `'<]z"uFc-UiyQVrcJW"@"v)QAC@'4Z_=zLI6K^} iAm40*1m*tc"dD/|iA1 #QP [Xp9.r?h]VL E(<Ui
\.yQ!Z iZVP=%:kbT>l:m*p;>mMJ*JY5!>ZPIa5D@ y#pjhs-VHHI=u8`\2^"^&OzwJbcFFumVN(IU}N]M+`z\rKzRx(P#	@|0)	Zjplg5hTm&:*saj)+8_Z\3	zU=mc\[$|2*a#fGcvV/@	!w`b5.$}DJiO*GTkZa6V]b md%up&E={"yG[JXBJ* j jif:MKY+}PL+L=-xY'Z#6 j<`FZXn-Ry:Ft;!7;w+EQ9:K:*{)Mpzt:5*1@^x6"ot4%v>p11ppugQn*^
:!4[f?!)+8]Ix5FS5d'<*lL(I*0&okSuy)1.8ab	 "{8X54I@)zyYX&H<TwYR~H<usRt	L
36
0^D
:aCL=m>|/7)8/:]fU*i%JzzK'vRob{(R][RuSWoyY3N{Bi;Q2|]~M>A{grekvpIyD @K*4G6E2[:f)2}]jC0hwtN0[eDIl#]d4D#^-==gPAU<vj9f-|kn[mQ,h~U
3nn_*ul@oJM?K)46\>f&.BM8ty`oHuJW4 ^M2~I^zQ=a<#llbaR=,0 T(p5tYqM5QVoxY%=[t+ZjW?\H`	8`q$$+ a	5pqQ}RW1p=2c@Xk.lDkQh"z=
K8g47@~w0%|*SMyHTc8 LZ\{FY.wK(<d(?)$+h!0<yw}XW~JN0GQ<tDPgn3
oi}!M/X2J!6ltw;|JMo65	H?dr#:,?lvd6x[
0 )_M6 "$-Z#iy's&y7@N		AtN);D2XE8t7_9Dxorj`2&Ib6
2f9>qna&] \JIJxTM00RMcPzlE+oj%#M{*q6%f73ZS>~z3m4I&pc
,?_>II	0&Ct"E@*#BBB<l%{_C3Z`=VE\bpQ I6|uF;Z&Q<GI%aAoffI<xaU]{;P,_[ul_'!w\]yD#Z.o-v&"	#AUCE'%D0V0))|$[AAe;\fYD\PI	xppnxeL\ZaI))w-@X~zKy)~H8Aj8w^~w{"b><8_s7t/Yx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]SJwN!'SK) yWxuTO0JCDRMtlT%M*+xKqhaAWF?{]{"YaY$)B t\OO?*B&;D=L*?ePR}yG+(d9ppmv2V+6plR[!aYTs)~}X'=~
uD|+pdb-RC*Wd"2PuSR*(Mu,<r],
c(P}rObgjpqJVP>8EIuZw<
;;
9:%Yr|@kpdY@Z.X~gu7f4l&u7Nd3rR7CE5}U KU(~3vN!0/EtsMbwYJ2LenQT
RKgGEQiwZ`jM2#I7wPF-Y>e:?'a1u&1*yiZcxY.{},v^y-#*dT	r1xV]o03}<l[:ITMhBbE#i}NbxI{}bN>|z2i6Jg	\}0"k K${4%Bb\CtYH<|K!V}M~n ]MLJ	aKiDp(-t4pP3I()@Gv(/L<$vD)[(->TI1;siXY(2\D^29 9Fb5\v>cW2kJ%c&!	R*NqNjZ-g<8Qs!yHivE]j%[tBM%=lgJtzA ])n7NxsB7ZDt#5Fs^UW6Z T,H
%pv8;=\f@i.]T^"EHG Niea`
pW	= )MW~+R*f7GCX>56xBf+/,}TT9J9w}``:
V=(x1L 5$oKA`\
xhWsTB%][ ]F{0ozVX[%LdT@V0c
E~G.l_ h4ZGDp}=rX?]M1XzKe-9;s2}:5] '_EjxN"kEZqR+^?Owg&dg`G"AC70N9hVj~I64evgNOscD5RYAbcGx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S4f=uglsS Yx+)JMU062d040031Qp-K++(`,Q"t5+4-.*tO.;U\?/|M{%4@M9}OeMSWa3v*s+JM-/,cnkJ04$373/pjY.eTYHjE_~
D]bCkgnbf?'k,sC9|6_t:rO_P%%VRkUTo` `xA
0 ={dw?IZl43K_qf2U`xEK:!$jSKgQVkq[!
3oRb4!&nu+\9>sL'yq-gn
7<KxTM005$R{=C)MHrwHJFo{3;k]h	v@]3({|nn6??Hbx<R0E@nvU!1)0\/NpApnJ)KjYTRC~PIxz6EbR_f!EL G2|cC0CBf?\*hRh%@_8Ug8wKdJ]cP{y`M.I/;{dGH3H%=2#6}JRIH!m6JNv?)7Pe03d-(e(+2r E=e6\`"JKV)qwTjA=[}<B16=t_6"uOO1]t_,Wx[
0E*_4d2H7
<bYAH1h!-jB7(JJX1i	5Te{OLk^'O0XYd?srm\JdoTIKxU]o0RTZT!L4!=xjpmvk;_]E~sPw?=h5nc2.m90c-$	-e?+7`ZI.Z--9$<4;9f_L-	xpIVC+,|6,YdK	bhV>hRbs+$J4x biHhQBmAVAW	t*a[Ke:$cZ y ;n)q4p_>,?(}O"k(5/hP:A]U!Slhk&me*MTtj5tYa'4~N Ah	*99_Pr*<eSxS$;~=_ !,{pfkds+OakxsyTBz*c88fK6D8,Z.,)iP7(b0C|F}cMm#t +[%x+)JMU044b040031QH,(+(`h>"A?.0mA"=I=v.2CG*CeVe0E+YfFRG V/x+)JMU025d040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c`J9Ys31 |Zt{6v
WzNH-I-f}Ir/P5Yu:=*]&\RP@D?l]% ex[k@,aejiI\BPC+i/w6NnssJatz -D!I~]N0&tbCLOeZ?]8QK$J*AiW%Wa"C@;^;ANB<!]x,TU+j9{aY7:\E J9d0 n{UgMs'1];0:nI!b7zF;;-4|o;	4qf`i5)Yap6|>P6auV5S?;rBN\Cm{1j1VmJiqd\mX=Nx+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S*]NeU2eZxSOO0Lw!$tK;,c0R9?;ql($fx,['`=dIBn5O,h6@
7J=R)YFs,U
t5juqH		CF&]i/?H<aWOM3EDBHjnwN 'wUJy65jK"@!
pxBqQ%9{lG3pl>(R3~vXmLR01HVJ[gh>;)LJJ TzD%"UZT~	_LSrxUn@30EVc4}iDi *9^kB*Oxg|3k?}8zs<i6-XxOO}KILMmqo^vql R  ^$`B))80r+dR=21IdQ!C0jH&Oa*EVIOWgD>\nhwI>)Sv8{j{]Z;IKB54Bw@nTs/A%\3WKhvYG(b!,s^ct\VGzh7+`+FLpvt@:SUE{jgY
%5FKUlgc`QS4$`\cyXDlnwCQfORROuN'#p\|DYd]:2`Ge43i	2= b\%a$YWubB2tUY<+-V9wtl-=QaUTsU\J>1	2YEk7lt=8{Kw<]HmZ|kprG_Ed*H1;}o/$xT]o03!%M["M}=LZq/mFkRu/O7oVEET#|?I^^v7MgQ36X)FMtU^{vVR<j6RIxxJknt+S{LkvCB
 +s[:sh}q8`v?v&XfQ,/`P$>sBz`H,EC-g?rEx4$<AAWxHgv))aB]-8g0"Vp:K+PR6)&@R:l>(])HLi)xLhmr~1WOh1{5X=p[px9,>9$c@m!)x+)JMU024c040031QK,L/JeXu[*q*U/7!7bnUQg*J-/N-*c0Ui^P2 RRs>P}7Y{g=m6=*]S:7-c|jrYxTQk0I ]V8}(>mE9d$i0;Ic{-wP;z(`IZm~oo5J?]EQBI6"U;sA0r(	oZJns%+i.#wLkvCBPsrsv(K<{qc%:-\#AHGb4RKxhLgnG=SI,wECMg?REx|c'<APyHg[y
B+\T$/ZW\4b18r	?Ji9"Gq~N`W'Il}g=kv)!Uz>e	3mW^
my'#A@33i^cf8'wrtv=<V>EmomEU!n hQk7b077eed534d7aec5b646f5fe01f36f71fad33bdbc
077eed534d7aec5b646f5fe01f36f71fad33bdbc
<?php

namespace Syntaxx\PHPX\Demo;

use Syntaxx\PHPX\Framework\Component;
use Syntaxx\PHPX\Framework\Runtime;
use Syntaxx\PHPX\Framework\Document;

require_once __DIR__ . '/../src/bootstrap.php';

function MyApp()
{
    return Component::create("div", [], [
        Component::create("h1", [], ["Counters that update separately"]),
        Component::create("MyButton", [], [])
    ]);
}

function MyButton()
{
    [$count, $setCount] = useState(0);
    $handleClick = function () use ($count, $setCount) {
        $setCount($count + 1);
    };
    return Component::create("button", ["onClick" => $handleClick], [" Clicked ", $count, "times "]);
}

$root = Runtime::createRoot(Document::document()->getElementById('root'));
$root->render(
    Component::create("StrictMode", [], [
        Component::create("MyApp", [], [])
    ])
);
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/10.0/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
         verbose="true">
    <testsuites>
        <testsuite name="PHPX Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
    
    <coverage>
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </coverage>
    
    <php>
        <env name="APP_ENV" value="testing"/>
    </php>
</phpunit> <?php

namespace Syntaxx\PHPX\Framework;

class Component
{
    public $type;
    public $props;
    public $children;

    public function __construct(string $type, array $props = [], array $children = [])
    {
        $this->type = $type;
        $this->props = $props;
        $this->children = $children;
    }

    public static function create(string $type, array $props = [], array $children = []): self
    {
        return new self($type, $props, $children);
    }

    public function render(): string
    {
        $attributes = '';
        foreach ($this->props as $key => $value) {
            if (strpos($key, 'on') === 0) {
                // For event handlers, we'll handle them in Runtime
                continue;
            }
            $attributes .= " {$key}=\"{$value}\"";
        }

        $childrenHtml = '';
        foreach ($this->children as $child) {
            if ($child instanceof Component) {
                $childrenHtml .= $child->render();
            } else {
                $childrenHtml .= htmlspecialchars($child);
            }
        }

        return "<{$this->type}{$attributes}>{$childrenHtml}</{$this->type}>";
    }

    public function getType(): string
    {
        return $this->type;
    }

    public function getProps(): array
    {
        return $this->props;
    }

    public function getChildren(): array
    {
        return $this->children;
    }
} 
<?php

namespace Syntaxx\PHPX\Framework;

class Document {
    private static $instance = null;
    private $document;

    private function __construct() {
        $window = new \Vrzno;
        $this->document = $window->document;
    }

    public static function document(): self {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public function getElementById(string $id) {
        return $this->document->getElementById($id);
    }

    public function createElement(string $tagName) {
        return $this->document->createElement($tagName);
    }

    public function createTextNode(string $text) {
        return $this->document->createTextNode($text);
    }

    public function querySelector(string $selector) {
        return $this->document->querySelector($selector);
    }

    public function addEventListener(string $event, callable $listener) {
        $this->document->addEventListener($event, $listener);
    }

    public function querySelectorAll(string $selector) {
        return $this->document->querySelectorAll($selector);
    }
}
<?php

namespace Syntaxx\PHPX\Framework;

class Element {
    private $tagName;
    private $id;
    private $attributes = [];
    private $children = [];
    private $eventListeners = [];

    public function __construct(string $tagName, string $id) {
        $this->tagName = $tagName;
        $this->id = $id;
    }

    public function setAttribute(string $name, string $value): void {
        $this->attributes[$name] = $value;
    }

    public function addEventListener(string $event, callable $listener): void {
        if (!isset($this->eventListeners[$event])) {
            $this->eventListeners[$event] = [];
        }
        $this->eventListeners[$event][] = $listener;
    }

    public function appendChild($child): void {
        $this->children[] = $child;
    }

    public function toJavaScript(string $id): string {
        $js = "elements['{$id}'] = document.createElement('{$this->tagName}');\n";
        
        foreach ($this->attributes as $name => $value) {
            $js .= "elements['{$id}'].setAttribute('{$name}', '{$value}');\n";
        }

        foreach ($this->eventListeners as $event => $listeners) {
            foreach ($listeners as $index => $listener) {
                $js .= "elements['{$id}'].addEventListener('{$event}', function(e) {\n";
                $js .= "    // Call PHP event handler\n";
                $js .= "    fetch('/php-handler', {\n";
                $js .= "        method: 'POST',\n";
                $js .= "        body: JSON.stringify({\n";
                $js .= "            elementId: '{$id}',\n";
                $js .= "            event: '{$event}',\n";
                $js .= "            listenerIndex: {$index}\n";
                $js .= "        })\n";
                $js .= "    });\n";
                $js .= "});\n";
            }
        }

        foreach ($this->children as $child) {
            if ($child instanceof Element) {
                $js .= $child->toJavaScript($child->id) . "\n";
                $js .= "elements['{$id}'].appendChild(elements['{$child->id}']);\n";
            } elseif ($child instanceof TextNode) {
                $js .= "elements['{$id}'].appendChild(document.createTextNode('" . 
                    addslashes($child->getText()) . "'));\n";
            }
        }

        return $js;
    }
} <?php

namespace Syntaxx\PHPX\Framework;

class Framework
{
    private static array $states = [];
    private static int $stateIndex = 0;
    private static array $components = [];

    public static function useState($initialValue): array
    {
        $currentIndex = self::$stateIndex;
        
        if (!isset(self::$states[$currentIndex])) {
            self::$states[$currentIndex] = $initialValue;
        }

        $state = self::$states[$currentIndex];
        $setState = function($newValue) use ($currentIndex) {
            self::$states[$currentIndex] = $newValue;
            self::render();
        };

        self::$stateIndex++;
        return [$state, $setState];
    }

    public static function registerComponent(string $name, callable $component): void
    {
        if (isset(self::$components[$name])) {
            throw new \RuntimeException("Component {$name} is already registered");
        }
        self::$components[$name] = $component;
    }

    public static function renderComponent(string $name, array $props = []): string
    {
        if (!isset(self::$components[$name])) {
            throw new \RuntimeException("Component {$name} not found. Did you forget to register it?");
        }

        try {
            $component = self::$components[$name];
            return $component($props);
        } catch (\Exception $e) {
            error_log("Error rendering component {$name}: " . $e->getMessage());
            return "<div class='error'>Error rendering component {$name}</div>";
        }
    }

    public static function render(): void
    {
        if (!isset(self::$components['App'])) {
            throw new \RuntimeException("App component not found. Please register an App component.");
        }

        self::$stateIndex = 0;
        try {
            $output = self::renderComponent('App');
            echo $output;
        } catch (\Exception $e) {
            error_log("Error during render: " . $e->getMessage());
            echo "<div class='error'>Error during render</div>";
        }
    }

    public static function init(): void
    {
        try {
            // Register VRZNO event handlers
            echo '<script src="https://vrzno.js"></script>';
            echo '<script>
                window.vrzno = new VRZNO();
                window.vrzno.on("event", function(event) {
                    try {
                        // Handle events from PHP components
                        console.log("Event received:", event);
                    } catch (e) {
                        console.error("Error handling event:", e);
                    }
                });
            </script>';
        } catch (\Exception $e) {
            error_log("Error during framework initialization: " . $e->getMessage());
        }
    }
} <?php

namespace Syntaxx\PHPX\Framework;

class Runtime
{
    private $rootElement;
    private static $stateHooks = [];
    private static $hookIndex = 0;
    private static $currentRoot = null;
    private static $currentComponent = null;
    private static $componentRegistry = [];
    private static $componentStates = [];
    private static $currentComponentId = null;
    private static $currentComponentFunction = null;
    private static $handlerMappings = [];

    public static function createRoot($element): self
    {
        self::$currentRoot = new self($element);
        $GLOBALS['__PHPX_ROOT__'] = self::$currentRoot;
        return self::$currentRoot;
    }

    private function __construct($element)
    {
        $this->rootElement = $element;
    }

    public function render($component)
    {
        self::$currentComponent = $component;
        $GLOBALS['__PHPX_COMPONENT__'] = $component;
        self::$hookIndex = 0; // Reset hook index for new render
        self::$currentComponentId = spl_object_hash($component);
        
        // Debug: Log the component being rendered
        //var_dump("Rendering component:", $component);
        
        // Clear the root element
        $this->rootElement->innerHTML = '';
        
        // Render the component tree
        $html = $this->renderComponentToString($component);
        
        // Debug: Log the generated HTML
        //var_dump("Generated HTML:", $html);
        
        // Update the DOM
        $this->rootElement->innerHTML = $html;

        // Bind event handlers
        $this->bindEventHandlers();
    }

    private function bindEventHandlers()
    {
        /*$window = new \Vrzno;
        $document = $window->document;

        $document->querySelector('button')->addEventListener('click', function()  {
            var_dump("Delete button clicked");
        });*/

        // Find all elements with data-handler-id
        $nodeList = Document::document()->querySelectorAll('[data-handler-id]');
        //var_dump("Found NodeList for elements with handlers");
        
        // Get the length of the NodeList
        $length = $nodeList->length;
        //var_dump("Number of elements found:", $length);
        //var_dump($nodeList);
        // Iterate through the NodeList
        for ($i = 0; $i < $length; $i++) {
            $element = $nodeList->item($i);
            $handlerId = $element->getAttribute('data-handler-id');
            var_dump("Binding handler for element with ID:", $handlerId);
            $self = $this;
            // Create a new event handler that will be recreated on each render
            $element->addEventListener('click', function() use ($handlerId, $self) {
                //var_dump("Click event triggered for handler ID:", $handlerId);

                // Get the handler mapping
                if (isset(self::$handlerMappings[$handlerId])) {
                    $mapping = self::$handlerMappings[$handlerId];
                    $handler = $mapping['handler'];
                    $props = $mapping['props'];
                    
                    try {
                        // Execute the handler with the props
                        $handler($props);
                        //var_dump("Handler executed successfully");
                        // Force a re-render
                        if (isset($GLOBALS['__PHPX_ROOT__'])) {
                            $GLOBALS['__PHPX_ROOT__']->render($GLOBALS['__PHPX_COMPONENT__']);
                        }
                    } catch (\Exception $e) {
                        var_dump("Error executing handler:", $e->getMessage());
                    }
                }
            });
        }
    }

    private function renderComponentToString($component): string
    {
        if (is_string($component)) {
            return htmlspecialchars($component);
        }

        if ($component instanceof Component) {
            // Debug: Log the component being processed
            //var_dump("Processing component:", $component->type);
            //var_dump("Component props:", $component->props);
            
            // Check if this is a custom component
            $componentName = $component->type;
            
            // First check in component registry
            if (isset(self::$componentRegistry[$componentName])) {
                // Store the current component function
                self::$currentComponentFunction = self::$componentRegistry[$componentName];
                //var_dump("Found component in registry:", $componentName);
                
                // It's a registered component, call it with props
                $nestedComponent = self::$componentRegistry[$componentName]($component->props);
                // Clear the current component function
                self::$currentComponentFunction = null;
                // Debug: Log the result of component function
                //var_dump("Component function result:", $nestedComponent);
                return $this->renderComponentToString($nestedComponent);
            }
            
            // Then check in App namespace
            $appComponentName = "\\Syntaxx\\PHPX\\Demo\\{$componentName}";
            if (function_exists($appComponentName)) {
                // Store the current component function
                self::$currentComponentFunction = $appComponentName;
                //var_dump("Found component in App namespace:", $appComponentName);
                
                // Make useState available in the component's namespace
                if (!function_exists("\\Syntaxx\\PHPX\\Demo\\useState")) {
                    eval('namespace Syntaxx\\PHPX\\Demo; function useState($initialValue) { return \\Syntaxx\\PHPX\\Framework\\Runtime::useState($initialValue); }');
                }
                
                // It's a function component, call it with props
                $nestedComponent = $appComponentName($component->props);
                // Clear the current component function
                self::$currentComponentFunction = null;
                // Debug: Log the result of component function
                //var_dump("Component function result:", $nestedComponent);
                return $this->renderComponentToString($nestedComponent);
            }

            // Regular HTML element
            $attributes = '';
            $eventHandlers = [];
            foreach ($component->props as $key => $value) {
                if (strpos($key, 'on') === 0) {
                    // Store event handlers for later binding
                    $eventHandlers[$key] = $value;
                    // Generate a unique ID for the element
                    $handlerId = uniqid('handler_');
                    //var_dump("Generated handler ID:", $handlerId, "for {$key} handler:", $value);
                    // Store the handler mapping
                    self::$handlerMappings[$handlerId] = [
                        'handler' => $value,
                        'props' => $component->props
                    ];
                    $attributes .= " data-handler-id=\"{$handlerId}\"";
                } else {
                    $attributes .= " {$key}=\"{$value}\"";
                }
            }

            $childrenHtml = '';
            foreach ($component->children as $child) {
                if ($child instanceof Component) {
                    // Propagate props to child components
                    $childProps = array_merge($child->props, $component->props);
                    $child->props = $childProps;
                    $childrenHtml .= $this->renderComponentToString($child);
                } else {
                    $childrenHtml .= htmlspecialchars($child);
                }
            }

            return "<{$component->type}{$attributes}>{$childrenHtml}</{$component->type}>";
        }

        return '';
    }

    public static function getCurrentComponentFunction()
    {
        return self::$currentComponentFunction;
    }

    public static function registerComponent(string $name, callable $component): void
    {
        self::$componentRegistry[$name] = $component;
    }

    public static function useState($initialValue)
    {
        $componentFunction = self::getCurrentComponentFunction();
        if (!$componentFunction) {
            throw new \RuntimeException("useState must be called within a component");
        }

        // Initialize component state if not exists
        if (!isset(self::$componentStates[$componentFunction])) {
            self::$componentStates[$componentFunction] = [];
        }

        $index = self::$hookIndex;
        
        // Initialize state if not exists
        if (!isset(self::$componentStates[$componentFunction][$index])) {
            self::$componentStates[$componentFunction][$index] = $initialValue;
        }

        $value = self::$componentStates[$componentFunction][$index];
        
        // Create setState function
        $setValue = function($newValue) use ($componentFunction, $index) {
            // If newValue is a function, call it with current state
            if (is_callable($newValue)) {
                $newValue = $newValue(self::$componentStates[$componentFunction][$index]);
            }

            // Update state
            self::$componentStates[$componentFunction][$index] = $newValue;
            
            // Debug: Log state update
            //var_dump("State updated for component {$componentFunction}:", $index, $newValue);
            
            // Trigger re-render
            if (isset($GLOBALS['__PHPX_ROOT__'])) {
                $GLOBALS['__PHPX_ROOT__']->render($GLOBALS['__PHPX_COMPONENT__']);
            }
        };

        self::$hookIndex++;
        return [$value, $setValue];
    }

    public static function handleStateUpdate($index, $value)
    {
        if (!isset(self::$stateHooks[$index])) {
            throw new \RuntimeException("State hook at index {$index} does not exist");
        }
        
        self::$stateHooks[$index] = $value;
        
        if (self::$currentRoot && self::$currentComponent) {
            self::$currentRoot->render(self::$currentComponent);
        }
    }
}
<?php

namespace Syntaxx\PHPX\Framework;

class TextNode {
    private $text;

    public function __construct(string $text) {
        $this->text = $text;
    }

    public function getText(): string {
        return $this->text;
    }
} <?php

namespace Syntaxx\PHPX\Framework;

require_once __DIR__ . '/vendor/autoload.php';

// Initialize Vrzno
if (!class_exists('Vrzno')) {
    throw new \RuntimeException('Vrzno class not found. Please install the Vrzno package.');
}
$window = new \Vrzno;
$document = $window->document;

// Initialize globals
$GLOBALS['__PHPX_ROOT__'] = null;
$GLOBALS['__PHPX_COMPONENT__'] = null;
$GLOBALS['__PHPX_HANDLERS__'] = [];

// Debug: Log initialization
var_dump("Framework initialized");

// Register global functions
function useState($initialValue) {
    return Runtime::useState($initialValue);
}

// Register global Component class
function Component($type, $props = [], $children = []) {
    return Component::create($type, $props, $children);
}

// Handle state updates
$document->addEventListener('stateUpdate', function($event) {
    try {
        $index = $event->detail->index;
        $value = $event->detail->value;
        // Debug: Log state update event
        var_dump("State update event received:", $index, $value);
        Runtime::handleStateUpdate($index, $value);
    } catch (\Exception $e) {
        error_log("State update error: " . $e->getMessage());
    }
});

// Handle click events through event delegation
$document->addEventListener('click', function($event) {
    $target = $event->target;
    while ($target) {
        $handlerId = $target->getAttribute('data-handler-id');
        if ($handlerId && isset($GLOBALS['__PHPX_HANDLERS__'][$handlerId])) {
            $handler = $GLOBALS['__PHPX_HANDLERS__'][$handlerId];
            $handler();
            break;
        }
        $target = $target->parentElement;
    }
});

// Handle PHP event handlers
if ($_SERVER['REQUEST_METHOD'] === 'POST' && $_SERVER['REQUEST_URI'] === '/php-handler') {
    $data = json_decode(file_get_contents('php://input'), true);
    $elementId = $data['elementId'];
    $event = $data['event'];
    $listenerIndex = $data['listenerIndex'];
    
    $element = Document::document()->getElementById($elementId);
    $listeners = $element->getEventListeners($event);
    
    if (isset($listeners[$listenerIndex])) {
        $listeners[$listenerIndex]();
    }
    
    exit;
} <?php

namespace Syntaxx\PHPX\Framework;

function useState($initialValue)
{
    return Runtime::useState($initialValue);
}<?php

namespace Syntaxx\PhpWasm;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Package\PackageInterface;
use Composer\Script\Event;

class Installer
{
    private const RELEASE_URL_PATTERN = 'https://github.com/Syntaxx-HQ/PHPX-phpwasmbuilder/releases/download/v%s/php-vrzno-web.%s';
    private const FILES = [
        'mjs' => 'php-vrzno-web.mjs',
        'wasm' => 'php-vrzno-web.wasm'
    ];

    public static function install(Event $event)
    {
        $composer = $event->getComposer();
        $io = $event->getIO();
        $package = $composer->getPackage();
        //$version = self::getVersion($package);
        
        // Get dependency information
        $dependencies = self::getDependencyInfo($composer, $io);
        
        // Get current package name
        $thisPackageName = self::getCurrentPackageName();
        $io->write(sprintf('Using package: %s', $thisPackageName));
        
        // Extract version for this package
        if (isset($dependencies[$thisPackageName])) {
            $version = $dependencies[$thisPackageName]['version'];
            $io->write(sprintf('Package version: %s', $version));
        } else {
            $io->writeError(sprintf('Package %s not found in dependencies', $thisPackageName));
            throw new \RuntimeException('Package not found in dependencies');
        }

        $io->write(sprintf('Installing PHP WASM version: %s', $version));
        
        $config = $package->getExtra()['php-wasm'] ?? [];
        $targetDir = $config['target-dir'] ?? __DIR__ . '/../../../public/wasm';

        if (!is_dir($targetDir)) {
            mkdir($targetDir, 0777, true);
        }

        foreach (self::FILES as $extension => $filename) {
            $url = sprintf(self::RELEASE_URL_PATTERN, $version, $extension);
            $targetPath = $targetDir . '/' . $filename;

            try {
                if (self::downloadFile($url, $targetPath)) {
                    $io->write(sprintf('Downloaded %s to %s', $filename, $targetPath));
                }
            } catch (\Exception $e) {
                $io->writeError(sprintf('Error downloading %s: %s', $filename, $e->getMessage()));
                throw $e; // Re-throw to ensure Composer knows about the failure
            }
        }
    }

    private static function downloadFile(string $url, string $targetPath): bool
    {
        $context = stream_context_create([
            'http' => [
                'method' => 'GET',
                'header' => [
                    'User-Agent: Composer/1.0',
                ],
                'ignore_errors' => true, // This allows us to get the response even for error status codes
            ],
        ]);

        $content = @file_get_contents($url, false, $context);
        if ($content === false) {
            $error = error_get_last();
            throw new \RuntimeException(sprintf(
                "Failed to download from URL: %s\nError: %s",
                $url,
                $error['message'] ?? 'Unknown error'
            ));
        }

        // Check HTTP status code
        if (isset($http_response_header[0])) {
            preg_match('{HTTP/\S*\s(\d{3})}', $http_response_header[0], $match);
            $statusCode = $match[1] ?? null;
            
            if ($statusCode === '404') {
                throw new \RuntimeException(sprintf(
                    "File not found (404): %s\nPlease check if the version exists in the releases.",
                    $url
                ));
            }
            
            if ($statusCode >= 400) {
                throw new \RuntimeException(sprintf(
                    "HTTP error %s while downloading: %s\nResponse: %s",
                    $statusCode,
                    $url,
                    $content
                ));
            }
        }

        $result = file_put_contents($targetPath, $content);
        if ($result === false) {
            throw new \RuntimeException(sprintf(
                "Failed to write file to: %s\nError: %s",
                $targetPath,
                error_get_last()['message'] ?? 'Unknown error'
            ));
        }

        return true;
    }

    private static function getDependencyInfo(Composer $composer, IOInterface $io): array
    {
        $repository = $composer->getRepositoryManager()->getLocalRepository();
        $dependencies = [];
        
        // Get all installed packages
        foreach ($repository->getPackages() as $package) {
            $dependencies[$package->getName()] = [
                'version' => preg_replace('/^v|(-dev|-alpha|-beta).*$/', '', $package->getPrettyVersion()),
                'requires' => array_map(function($require) {
                    return [
                        'package' => $require->getTarget(),
                        'constraint' => $require->getConstraint()->getPrettyString()
                    ];
                }, $package->getRequires())
            ];
        }
        
        return $dependencies;
    }

    private static function getCurrentPackageName(): string
    {
        // Go up 3 levels from src/Installer.php to reach the root directory
        $composerJsonPath = __DIR__ . '/../composer.json';
        
        if (!file_exists($composerJsonPath)) {
            throw new \RuntimeException('Could not find composer.json in parent directory');
        }
        
        $composerJson = json_decode(file_get_contents($composerJsonPath), true);
        if (!isset($composerJson['name'])) {
            throw new \RuntimeException('No package name found in composer.json');
        }
        
        return $composerJson['name'];
    }
}
<?php

namespace Syntaxx\PhpWasm;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;

class Plugin implements PluginInterface, EventSubscriberInterface
{
    public function activate(Composer $composer, IOInterface $io)
    {
        // Plugin activation logic
    }

    public function deactivate(Composer $composer, IOInterface $io)
    {
        // Plugin deactivation logic
    }

    public function uninstall(Composer $composer, IOInterface $io)
    {
        // Plugin uninstall logic
    }

    public static function getSubscribedEvents()
    {
        return [
            'post-install-cmd' => 'onPostInstallCmd',
            'post-update-cmd' => 'onPostInstallCmd',
        ];
    }

    public function onPostInstallCmd(Event $event)
    {
        Installer::install($event);
    }
} 